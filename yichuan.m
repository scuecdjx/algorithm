clc;clear;
sj0=load('sj.txt');
x=sj0(:,1:2:8);x=x(:);
y=sj0(:,2:2:8);y=y(:);
sj=[x y];%100个地点坐标
d1=[70,40];%初始位置
sj0=[d1;sj;d1];%102个坐标
sj=sj0*pi/180;%单位化成弧度，计算距离
d=zeros(102);%距离矩阵
for i=1:101    %101段距离
    for j=i+1:102%计算距离
        d(i,j)=6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*cos(sj(j,2))+sin(sj(i,2))*sin(sj(j,2)));
    end
end
d=d+d';%上三角转化
w=50;g=100;%w为种群个数，g为进化的代数
rand('state',sum(clock));%初始化随机发生器
for k=1:w%通过改良圈算法选取初始种群
    c=randperm(100);%产生1~100的一个全数列
    c1=[1 c+1 102];%生成初始解
    for t=1:102%该层循环是修改圈
        flag=0;%修改圈退出标志
        for u=1:100
            for v=u+2:101
                if d(c1(u),c1(v))+d(c1(u+1),c1(v+1))<d(c1(u),c1(u+1))+d(c1(v),c1(v+1))
                    c1(u+1:v)=c1(v:-1:u+1);%递减后交换
                    flag=1;%修改圈
                end
            end
        end
        if flag==0
            J(k,c1)=1:102;break%记录较好的解并退出当前循环
        end
    end
end
J(:,1)=0;J=J/102;%吧整数序列转换成【0,1】区间的实数，即转换成染色体编码
for k=1:g%该层循环进行遗传算法的操作
    A=J;%交配产生子代A的初始染色体
    c=randperm(w);%产生下面交叉操作的染色体对
    for i=1:2:w
        F=2+floor(100*rand(1));%产生交叉操作的地址
        temp=A(c(1),[F:102]);%中间变量的保存值
        A(c(i),[F:102])=A(c(i+1),[F:102]);%交叉操作
        A(c(i+1),F:102)=temp;
    end
    by=[];
    while ~length(by)
        by=find(rand(1,w)<0.1);%产生编译操作的地址
    end
    B=A(by,:);%产生变异操作的初始染色体
    for j=1:length(by)
        bw=sort(2+floor(100*rand(1,3)));%产生变异操作的3个地址
        B(j,:)=B(j,[1:bw(1)-1,bw(2)+1:bw(3),bw(1):bw(2),bw(3)+1:102]);%交换位置,变异操作
    end
    G=[J;A;B];%父代和子代种群结合在一起
    [SG,ind1]=sort(G,2);%吧染色体翻译成1~102的序列ind1
    num=size(G,1);long=zeros(1,num);%路径长度的初始值
    for j=1:num
        for i=1:101
            long(j)=long(j)+d(ind1(j,i),ind1(j,i+1));%计算每条路径长度
        end
    end
    [slong,ind2]=sort(long);%对路径长度从小到大排序
    J=G(ind2(1:w),:);%精选前w个较短的路径对应的染色体
end
path=ind1(ind2(1),:);flong=slong(1)%解的路径及长度
xx=sj0(path,1);
yy=sj0(path,2);
plot(xx,yy,'-o')
        